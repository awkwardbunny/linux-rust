initSidebarItems({"fn":[["cond_resched","Reschedules the caller’s task if needed."],["new_refcount","Creates, from a const context, a new instance of `struct refcount_struct` with a refcount of 1."]],"mod":[["rcu","RCU support."],["smutex","A simple mutex implementation."]],"struct":[["CondVar","Exposes the kernel’s `struct wait_queue_head` as a condition variable. It allows the caller to atomically release the given lock and go to sleep. It reacquires the lock when it wakes up. And it wakes up when notified by another thread (via [`CondVar::notify_one`] or [`CondVar::notify_all`]) or because the thread received a signal."],["Guard","Allows mutual exclusion primitives that implement the [`Lock`] trait to automatically unlock when a guard goes out of scope. It also provides a safe and convenient way to access the data protected by the lock."],["LockClassKey","Represents a lockdep class. It’s a wrapper around C’s `lock_class_key`."],["LockedBy","Allows access to some data to be serialised by a lock that does not wrap it."],["Mutex","Exposes the kernel’s `struct mutex`. When multiple threads attempt to lock the same mutex, only one at a time is allowed to progress, the others will block (sleep) until the mutex is unlocked, at which point another thread will be allowed to wake up and make progress."],["NoWaitLock","A lock that only offers a `try_lock` method."],["NoWaitLockGuard","A guard for the holder of the no-wait lock."],["RawSpinLock","Exposes the kernel’s `raw_spinlock_t`."],["ReadLock","A marker for locks that only allow reading."],["Ref","A reference-counted pointer to an instance of `T`."],["RefBorrow","A borrowed [`Ref`] with manually-managed lifetime."],["Revocable","Revocable synchronisation primitive."],["RevocableGuard","A guard that allows access to a revocable object and keeps it alive."],["RwSemaphore","Exposes the kernel’s `struct rw_semaphore`."],["SeqLock","Exposes sequential locks backed by the kernel’s `seqcount_t`."],["SeqLockReadGuard","Allows read-side access to data protected by a sequential lock."],["SpinLock","Exposes the kernel’s `spinlock_t`. When multiple CPUs attempt to lock the same spinlock, only one at a time is allowed to progress, the others will block (spinning) until the spinlock is unlocked, at which point another CPU will be allowed to make progress."],["StaticRef","Allows the creation of “reference-counted” globals."],["UniqueRef","A refcounted object that is known to have a refcount of 1."],["WriteLock","A marker for locks that allow reading and writing."]],"trait":[["Lock","A generic mutual exclusion primitive."],["LockFactory","A creator of instances of a mutual exclusion (lock) primitive."],["LockInfo","Specifies properties of a lock."],["LockIniter","A lock that can be initialised with a single lock class key."],["NeedsLockClass","A trait for types that need a lock class during initialisation."]],"type":[["RevocableMutex","A revocable mutex."],["RevocableMutexGuard","A guard for a revocable mutex."],["RevocableRwSemaphore","A revocable rw semaphore."],["RevocableRwSemaphoreGuard","A guard for a revocable rw semaphore.."]]});